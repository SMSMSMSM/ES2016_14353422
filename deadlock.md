#Deadlock实验报告
###一、结果截图
①count=20000

![image](https://cl.ly/0a2O1d0x2L1s/%E5%9B%BE%E7%89%871.png)

运行到第十五次的时候卡住。

②count=100000

![image](https://cl.ly/3a1U3c1e0N1V/%E5%9B%BE%E7%89%872.png)

运行到第一百三十六次的时候卡住。

###二、产生死锁的4个必要条件：

①请求的资源每次只允许一个进程使用

②资源只能自愿释放

③一个进程因请求资源而阻塞时，对已获得的资源保持不放

④存在一个进程等待队列（进程等待环路）

###三、产生死锁的解释：

在上面的程序中同步线程正完成Runnable的接口，它工作的是两个对象，这两个对象向对方寻求死锁而且都在使用同步阻塞。同步中嵌套同步，会发生死锁。因为主线程调度a.methodA(b);使用synchronized获得B的锁，线程t运行时，调度run()中的b.method(a)使用synchronized获得A的锁，由于同步线程，有可能会出现先B再A和先A再B的情况，这是不会导致死锁的，之所以要运行那么多次，是想让其发生概率性事件：B和A恰巧同时请求对方的锁，造成死锁，这才是死锁的原因。