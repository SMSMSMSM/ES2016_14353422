#Deadlock实验报告
###一、结果截图
①count=20000

![image](https://cl.ly/0a2O1d0x2L1s/%E5%9B%BE%E7%89%871.png)

运行到第十五次的时候卡住。

②count=100000

![image](https://cl.ly/3a1U3c1e0N1V/%E5%9B%BE%E7%89%872.png)

运行到第一百三十六次的时候卡住。

###二、产生死锁的4个必要条件：

①请求的资源每次只允许一个进程使用

②资源只能自愿释放

③一个进程因请求资源而阻塞时，对已获得的资源保持不放

④存在一个进程等待队列（进程等待环路）

###三、产生死锁的解释：

在上面的程序中同步线程正完成Runnable的接口，它工作的是两个对象，这两个对象向对方寻求死锁而且都在使用同步阻塞。同步中嵌套同步，会发生死锁。因为线程t运行时，调度run()：由于同步线程，会出现先A后B和先B后A两种情况：①先B后A，b.method(a)因为使用了synchronized的缘故，B被锁定，并且获得了A的锁，然后进入休眠(while循环)，这时候要进行a.methodA(b);，但由于A的锁被占有，阻塞，直至被休眠的线程醒来才可以继续，至此，死锁；第二种情况亦然。